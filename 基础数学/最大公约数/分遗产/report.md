# 考点分析

本题属于最简单的数论题，主要考的是求最小公倍数的算法。只是题目没有直接说，把稍微做了一下隐藏。
测试数据主要检查程序的正确性，对时间和空间效率以及编程技巧的要求都比较小。所以本题的难度很低。
基本上能熟悉一门编程语言的都能通过。ACM中属于送分题。

# 难度级别

★★ Easy

# 算法分析

这里，我用题目的示例来解释一下本题的算法。
那个阿拉伯老人分给儿子的是1/2 + 1/4 + 1/6 = 11/12。并不是全部12/12 = 100%。
这里分子是11；分母是12。分子代表要分掉的财产。所以，老人留下的财产必须是分子的整数倍。 否则就不能用他邻居的方法来分遗产了。这一题中正好是11匹马，是11的倍数。
而为了能分遗产，必须预先把遗产数扩充到分母的大小。就像题目中，必须再另外领一匹马过来， 把遗产扩从到12匹马。而这个分母，就是a1, a2, ..., an的最小公倍数。
因此，我们最终要解决的算法是求a1, a2, ..., an这n个数的最小公倍数。
前n个数的最小公倍数等于前n-1个数的最小公倍数和第n个数的最小公倍数。
即lcm(a1, a2, ..., an) = lcm(lcm(a1, a2, ..., an-1), an)
所以，关键还是如何求两个数的最小公倍数。

求两个数a，b的最小公倍数方法很多：

## 方法1：

另i从a、b中的较大者开始循环，逐一判断i是否能同时被a，b整除，如果条件成立，i就是所求的最小公倍数。
当然从a，b中的较小者开始也一样能得到结果。但前面就做了一些无用功了。
这种方法是最简单，最直接的。没有任何算法基础的人也应该能写出来。
但直接用这种方法，一点也不改进。那就和做C语言的课后习题没有区别了，这样是无法通过本题的测试数据的。
有个很简单的改进方法:
我们假设输入的两个数a > b。
则从a 开始循环，循环的步长不是只增加1，而是每次增加a。
即从原来的for (i = a; i % a || i % b; i++); => for (i = a; i % b; i += a);
修改虽然不大，但效率提高很多！

## 方法2：

根据lcm(a, b) = a * b / gcd(a, b); (gcd 是求a，b的最大公约数)
只要问题就转换成求两个数的最大公约数了。
求最大公约数比较好的方法是用欧几里德GCD递归定理gcd(a, b) = gcd(b, a mod b);
这个定理的证明可以参看《算法导论》。
能使用这种方法解题的选手应该已经了解了一点算法的知识了。