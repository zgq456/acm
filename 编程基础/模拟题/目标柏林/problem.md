# Problem Description

1945年初，苏军和英美联军已从东西两面攻入德国国境。 4月初，在苏军和英美联军的夹击下，德军只能龟缩在以柏林为中心的德国东部的狭长地带，成了瓮中之鳖。 但希特勒困兽犹斗，一方面发出摧毁一切设施，实行“焦土”政策的指令； 另一方面下令把德国分为南北两个行政区，各自作战，他自己则固守柏林。
在这一天，苏军结果一份传自柏林的加密电文。经初步破译，显示希特勒要调集100万兵力， 在柏林周围筑起了三层防卫圈，并集中3300架飞机，1500多辆坦克，1万门火炮和迫击炮，准备死守柏林。 形势很危机，我们需要马上破译所有密码。请你来遍个程序帮忙破译。
苏军知道德军用的加密方法是这样的：
1.获得一段文字后，求出它的长度(包括空格)len。
2.进入加密运算的第1步:把所有下标是1倍数的字符做顺时针旋转。
3.进入加密运算的第2步:把所有下标是2倍数的字符做逆时针旋转。
4.进入加密运算的第3步:把所有下标是1倍数的字符做顺时针旋转。
5.按上面的规则，第奇数步按顺时针旋转，偶数步按逆时针旋转，一直到第len步为止。

比如原文是:abcde
1.获得长度len = 5
2.1的倍数有1、2、3、4、5，所以把这5个字符按顺时针旋转，得到eabcd。
3.2的倍数有2、4，所以把这2个字符按逆时针旋转，得到ecbad。
4.3的倍数有3，所以把这1个字符按顺时针旋转，得到ecbad。
5.4的倍数有4，所以把这1个字符按逆时针旋转，得到ecbad。
6.5的倍数有5，所以把这1个字符按顺时针旋转，得到ecbad。
最后的结果是ecbad。

现在给你加密后的文章，让你还原成原来的文章。

# Input

输入一篇加密后的文章，每行为一段。每段不超过1000个字符。
输入以文件结束(EOF)为止。

# Output

输出解密后的文章。
每段一行。

# Sample Input

ecbad

# Sample Output

abcde